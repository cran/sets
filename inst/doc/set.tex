\documentclass[fleqn]{article}
\usepackage[round,longnamesfirst]{natbib}
\usepackage{graphicx,keyval,thumbpdf,a4wide,makeidx,color,colordvi}
\usepackage{amsfonts,hyperref}

\newcommand\R{\textsf{R}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\sQuote}[1]{`{#1}'}
\newcommand{\dQuote}[1]{``{#1}''}
\newcommand{\file}[1]{\sQuote{\textsf{#1}}}
\newcommand{\data}[1]{\texttt{#1}}
\newcommand{\var}[1]{\textit{#1}}
\newcommand{\class}[1]{\textsf{#1}}
\newcommand{\proglang}[1]{\textsf{#1}}
%% \code without `-' ligatures
\def\nohyphenation{\hyphenchar\font=-1 \aftergroup\restorehyphenation}
\def\restorehyphenation{\hyphenchar\font=`-}
{\catcode`\-=\active%
  \global\def\code{\bgroup%
    \catcode`\-=\active \let-\codedash%
    \Rd@code}}
\def\codedash{-\discretionary{}{}{}}
\def\Rd@code#1{\texttt{\nohyphenation#1}\egroup}
\newcommand{\codefun}[1]{\code{#1()}}
\newcommand{\codefunind}[1]{\codefun{#1}\index{\texttt{#1}}}
\newcommand{\codeind}[1]{\code{#1}\index{\texttt{#1}}}



\AtBeginDocument{\setkeys{Gin}{width=0.5\textwidth}}

\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{Red}{rgb}{0.7,0,0}

\date{2007-10-09}
\title{(Generalized) Sets in \R}
\author{David Meyer and Kurt Hornik}
%\VignetteIndexEntry{Sets}
%\VignetteDepends{sets}
%\VignetteKeywords{set, tuple, multiset, fuzzy set}
%\VignettePackage{sets}

\makeindex{}

\sloppy{}

\usepackage{/home/meyer/bin/R-build/share/texmf/Sweave}
\begin{document}
\maketitle

\begin{abstract}
This document explains algorithms and basic operations of
sets and some generalizations of sets (fuzzy
sets, multisets, and fuzzy multisets) available in \R{} through the
\pkg{sets} package.
\end{abstract}


%\section{Introduction}
%\label{sec:introduction}

There is only rudimentary support in base \R{}~for \emph{sets}.
Typically, these are represented using atomic or recursive vectors
(lists), and one can use operations such as \codefun{union},
\codefun{intersect}, \codefun{setdiff}, \codefun{setequal}, and
\codefun{is.element} to emulate set operations.  However, there are
several drawbacks:  first of all, quite a few other operations such as
the Cartesian product, the power set, the subset predicate, etc., are
missing.  Then, the current facilities do not make use of a class
system, making extensions hard (if not impossible).  Another consequence
is that no distinction can be made between sequences (ordered
collections of objects) and sets (unordered collections of objects),
which is key for the definition of relations, where both concepts are
combined.  Also, there is no support for extensions such as fuzzy sets
or multisets. Therefore, we decided to provide more formalized and extended
support for sets, and, because they are needed for Cartesian products,
also for tuples.

\section{Tuples}
\label{sec:tuples}

The \emph{tuple} functions in package \pkg{sets} represent basic
infrastructure for handling tuples of general (\R) objects.  They are
used, e.g., to correctly represent Cartesian products of sets, resulting
in a set of tuples (see below).  Although tuple objects should behave
like \dQuote{ordinary} vectors for the most common operations (see
examples), some functions may yield unexpected results (e.g.,
\codefun{table}) or simply not work (e.g., \codefun{plot}) since tuple
objects are in fact list objects internally.  There are several
constructors:  \codefunind{tuple}
for arbitrarily many objects, and \codefunind{singleton},
\codefunind{pair}, and \codefunind{triple}
for tuples of lengths 1, 2 and 3, respectively.  Note that tuple elements
can be named.
\begin{Schunk}
\begin{Sinput}
> ## constructor
> tuple(1,2,3, TRUE)
\end{Sinput}
\begin{Soutput}
(1, 2, 3, TRUE)
\end{Soutput}
\begin{Sinput}
> triple(1,2,3)
\end{Sinput}
\begin{Soutput}
(1, 2, 3)
\end{Soutput}
\begin{Sinput}
> pair(Name = "David", Height = 185)
\end{Sinput}
\begin{Soutput}
(Name = David, Height = 185)
\end{Soutput}
\begin{Sinput}
> tuple_is_triple(triple(1,2,3))
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> tuple_is_ntuple(tuple(1,2,3,4), 4)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> ## converter
> as.tuple(1:3)
\end{Sinput}
\begin{Soutput}
(1, 2, 3)
\end{Soutput}
\begin{Sinput}
> ## operations
> c(tuple("a","b"), 1)
\end{Sinput}
\begin{Soutput}
(a, b, 1)
\end{Soutput}
\begin{Sinput}
> tuple(1,2,3) * tuple(2,3,4)
\end{Sinput}
\begin{Soutput}
(2, 6, 12)
\end{Soutput}
\begin{Sinput}
> rep(tuple(1,2,3), 2)
\end{Sinput}
\begin{Soutput}
(1, 2, 3, 1, 2, 3)
\end{Soutput}
\end{Schunk}
The \codefun{Summary} methods will also work if defined for the
elements:
\begin{Schunk}
\begin{Sinput}
> sum(tuple(1, 2, 3))
\end{Sinput}
\begin{Soutput}
[1] 6
\end{Soutput}
\begin{Sinput}
> range(tuple(1, 2, 3))
\end{Sinput}
\begin{Soutput}
[1] 1 3
\end{Soutput}
\end{Schunk}
In addition, there is a \codefunind{tuple\_outer}
function to apply functions to all combinations of tuple elements.  Note
that \codefun{tuple\_outer} will also work for regular vectors and thus
can really be seen as an extension of \codefun{outer}:
\begin{Schunk}
\begin{Sinput}
> tuple_outer(pair(1, 2), triple(1, 2, 3))
\end{Sinput}
\begin{Soutput}
  1 2 3
1 1 2 3
2 2 4 6
\end{Soutput}
\begin{Sinput}
> tuple_outer(1:5, 1:4, "^")
\end{Sinput}
\begin{Soutput}
  1  2   3   4
1 1  1   1   1
2 2  4   8  16
3 3  9  27  81
4 4 16  64 256
5 5 25 125 625
\end{Soutput}
\end{Schunk}

\section{Sets}
\label{sec:sets}

The basic constructor for creating sets is the \codefunind{set}
function accepting an arbitrary number of \R{}~objects as arguments
(which can be named).  In addition, there is a generic \codefunind{as.set}
for converting suitable objects to sets.
\begin{Schunk}
\begin{Sinput}
> ## constructor
> s <- set(1, 2, 3)
> s
\end{Sinput}
\begin{Soutput}
{1, 2, 3}
\end{Soutput}
\begin{Sinput}
> ## named elements
> snamed <- set(one = 1, 2, three = 3)
> snamed
\end{Sinput}
\begin{Soutput}
{one = 1, 2, three = 3}
\end{Soutput}
\begin{Sinput}
> ## named elements can directly be accessed
> snamed[["one"]]
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
> ## a more complex set
> set(c, "test", list(1, 2, 3))
\end{Sinput}
\begin{Soutput}
{<<function>>, test, <<list(3)>>}
\end{Soutput}
\begin{Sinput}
> ## set of sets
> set(set(), set(1))
\end{Sinput}
\begin{Soutput}
{{}, {1}}
\end{Soutput}
\begin{Sinput}
> ## conversion functions
> s2 <- as.set(2:5)
> s2
\end{Sinput}
\begin{Soutput}
{2, 3, 4, 5}
\end{Soutput}
\end{Schunk}
There are some basic predicate functions (and corresponding operators)
defined for the (in)equality, (proper) sub-(super-)set, and element-of.
Note that all the \codefun{set\_is\_\var{foo}} functions are vectorized:
\begin{Schunk}
\begin{Sinput}
> set_is_empty(set())
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set_is_equal(set(1), set(1))
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set(1) == set(1)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set(1) != set(2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set_is_subset(set(1), set(1, 2))
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set(1) <= set(1, 2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set(1, 2) >= set(1)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set_is_proper_subset(set(1), set(1))
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
> set(1) < set(1)
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
> set(1, 2) > set(1)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set_contains_element(set(1, 2, 3), 1)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> 1 %e% set(1, 2, 3)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> set_contains_element(set(1, 2, 3), 1:4)
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE  TRUE FALSE
\end{Soutput}
\begin{Sinput}
> 1:4 %e% set(1, 2, 3)
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE  TRUE FALSE
\end{Soutput}
\end{Schunk}
Other than these predicate functions and operators, one can use:
\codefun{c} and \code{|} for the union, \code{-} for the
difference (or complement), \code{\&} for the intersection, \code{\%D\%} for the
symmetric difference, \code{*} and \code{\^{ }$n$} for the ($n$-fold)
Cartesian product (yielding a set of $n$-tuples), and \code{2\^} for the
power set.  \codefunind{set\_union}, \codefunind{set\_intersection}, and
\codefunind{set\_symdiff} accept more than two arguments.\footnote{The
  $n$-ary symmetric difference of a collection of sets consists of all
  elements contained in an odd number of the sets in the collection.}
The \code{length} method for sets gives the cardinality.
\codefunind{set\_combn} returns the set of all subsets of specified
length.  Note that (currently) the \codefun{rep} method for sets will
just return its argument since set elements are unique.
\begin{Schunk}
\begin{Sinput}
> length(s)
\end{Sinput}
\begin{Soutput}
[1] 3
\end{Soutput}
\begin{Sinput}
> length(set())
\end{Sinput}
\begin{Soutput}
[1] 0
\end{Soutput}
\begin{Sinput}
> ## complement, union, intersection, symmetric difference:
> s - 1
\end{Sinput}
\begin{Soutput}
{2, 3}
\end{Soutput}
\begin{Sinput}
> s + set("a")
\end{Sinput}
\begin{Soutput}
{1, 2, 3, a}
\end{Soutput}
\begin{Sinput}
> s | set("a")
\end{Sinput}
\begin{Soutput}
{1, 2, 3, a}
\end{Soutput}
\begin{Sinput}
> s & s2
\end{Sinput}
\begin{Soutput}
{2, 3}
\end{Soutput}
\begin{Sinput}
> s %D% s2
\end{Sinput}
\begin{Soutput}
{4, 5, 1}
\end{Soutput}
\begin{Sinput}
> set(1,2,3) - set(1,2)
\end{Sinput}
\begin{Soutput}
{3}
\end{Soutput}
\begin{Sinput}
> set_intersection(set(1,2,3), set(2,3,4), set(3,4,5))
\end{Sinput}
\begin{Soutput}
{3}
\end{Soutput}
\begin{Sinput}
> set_union(set(1,2,3), set(2,3,4), set(3,4,5))
\end{Sinput}
\begin{Soutput}
{1, 2, 3, 4, 5}
\end{Soutput}
\begin{Sinput}
> set_symdiff(set(1,2,3), set(2,3,4), set(3,4,5))
\end{Sinput}
\begin{Soutput}
{3, 5, 1}
\end{Soutput}
\begin{Sinput}
> ## Cartesian product
> s * s2
\end{Sinput}
\begin{Soutput}
{(1, 2), (2, 2), (3, 2), (1, 3), (2, 3), (3, 3), (1, 4), (2, 4), (3,
 4), (1, 5), (2, 5), (3, 5)}
\end{Soutput}
\begin{Sinput}
> s * s
\end{Sinput}
\begin{Soutput}
{(1, 1), (2, 1), (3, 1), (1, 2), (2, 2), (3, 2), (1, 3), (2, 3), (3,
 3)}
\end{Soutput}
\begin{Sinput}
> s ^ 2 # same as above
\end{Sinput}
\begin{Soutput}
{(1, 1), (2, 1), (3, 1), (1, 2), (2, 2), (3, 2), (1, 3), (2, 3), (3,
 3)}
\end{Soutput}
\begin{Sinput}
> s ^ 3
\end{Sinput}
\begin{Soutput}
{(1, 1, 1), (2, 1, 1), (3, 1, 1), (1, 2, 1), (2, 2, 1), (3, 2, 1), (1,
 3, 1), (2, 3, 1), (3, 3, 1), (1, 1, 2), (2, 1, 2), (3, 1, 2), (1, 2,
 2), (2, 2, 2), (3, 2, 2), (1, 3, 2), (2, 3, 2), (3, 3, 2), (1, 1, 3),
 (2, 1, 3), (3, 1, 3), (1, 2, 3), (2, 2, 3), (3, 2, 3), (1, 3, 3), (2,
 3, 3), (3, 3, 3)}
\end{Soutput}
\begin{Sinput}
> ## power set
> 2 ^ s
\end{Sinput}
\begin{Soutput}
{{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
\end{Soutput}
\begin{Sinput}
> ## subsets:
> set_combn(as.set(1:3),2)
\end{Sinput}
\begin{Soutput}
{{1, 2}, {1, 3}, {2, 3}}
\end{Soutput}
\end{Schunk}
The \codefun{Summary} methods will also work if defined for the
elements:
\begin{Schunk}
\begin{Sinput}
> sum(s)
\end{Sinput}
\begin{Soutput}
[1] 6
\end{Soutput}
\begin{Sinput}
> range(s)
\end{Sinput}
\begin{Soutput}
[1] 1 3
\end{Soutput}
\end{Schunk}
Using \codefunind{set\_outer},
it is possible to apply a function on all factorial combinations of the
elements of two sets.  If only one set is specified, the function is
applied to all pairs of this set.
\begin{Schunk}
\begin{Sinput}
> set_outer(set(1, 2), set(1, 2, 3), "/")
\end{Sinput}
\begin{Soutput}
  1   2         3
1 1 0.5 0.3333333
2 2 1.0 0.6666667
\end{Soutput}
\begin{Sinput}
> X <- set_outer(set(1, 2), set(1, 2, 3), set)
> X[[2, 3]]
\end{Sinput}
\begin{Soutput}
{2, 3}
\end{Soutput}
\begin{Sinput}
> set_outer(2^set(1, 2, 3), set_is_subset)
\end{Sinput}
\begin{Soutput}
             {}   {1}   {2}   {3} {1, 2} {1, 3} {2, 3} {1, 2, 3}
{}         TRUE  TRUE  TRUE  TRUE   TRUE   TRUE   TRUE      TRUE
{1}       FALSE  TRUE FALSE FALSE   TRUE   TRUE  FALSE      TRUE
{2}       FALSE FALSE  TRUE FALSE   TRUE  FALSE   TRUE      TRUE
{3}       FALSE FALSE FALSE  TRUE  FALSE   TRUE   TRUE      TRUE
{1, 2}    FALSE FALSE FALSE FALSE   TRUE  FALSE  FALSE      TRUE
{1, 3}    FALSE FALSE FALSE FALSE  FALSE   TRUE  FALSE      TRUE
{2, 3}    FALSE FALSE FALSE FALSE  FALSE  FALSE   TRUE      TRUE
{1, 2, 3} FALSE FALSE FALSE FALSE  FALSE  FALSE  FALSE      TRUE
\end{Soutput}
\end{Schunk}
Because set elements are unordered,
it is not sensible to use positional
subscripting.  However, it is possible to iterate over \emph{all}
elements using \codefun{for} and \codefun{lapply}/\codefun{sapply}:
\begin{Schunk}
\begin{Sinput}
> sapply(s, sqrt)
\end{Sinput}
\begin{Soutput}
[1] 1.000000 1.414214 1.732051
\end{Soutput}
\begin{Sinput}
> for (i in s) print(i)
\end{Sinput}
\begin{Soutput}
[1] 1
[1] 2
[1] 3
\end{Soutput}
\end{Schunk}

\section{Generalized Sets}
\label{sec:gsets}

There are several extensions of \dQuote{ordinary} sets such as \emph{fuzzy sets}
and \emph{multisets}. Both can be be seen as special cases of
\emph{fuzzy multisets}. For all extensions, the approach is to define
a generalized set $X$ as a pair $(D, f)$ where $D$ is an ordinary set
representing the domain,
and $f$ the characteristic function of $X$, mapping
$D$ to some image $I$.  The subset of the domain for which $f$ is
non-zero is the support of $X$.
If $I=\{0, 1\}$, $X$
represents an \dQuote{ordinary} set. If $I=\mathbb{N}$, $X$ becomes
a multiset whose elements $e_i$ can appear multiple times. $f(e_i)$ is
then called the multiplicity of $e_i$. If $I$ is the unit interval,
$X$ becomes a fuzzy set. In this context, $f$ is typically called the membership
function, $f(e_i)$ the membership grade of $e_i$, and $D$ the universe
for $X$. If $I$ is a multiset whose domain is the unit interval (0 excluded),
$X$ is a fuzzy multiset whose elements can each have several
(possibly non-unique) membership grades. If for one element, the
asociated membership grades are all $1$, we get a multiset. If there
is at most one membership grade, we get a \dQuote{simple} fuzzy set. If for
the latter case the membership is $1$, we fall back to an ordinary set.

Generalized sets are created using the \codefun{gset} function. This
can be done in four ways:

\begin{enumerate}
\item Specify the support only (this yields an ordinary set).
\item Specify support and memberships.
\item Specify support and membership function.
\item Specify a set of elements along with their individual membership grades.
\end{enumerate}

\noindent Note that for efficiency reasons, \codefun{gset} will not
store elements with zero memberships grades, i.e. really expects the
support and not a domain (or universe in the fuzzy world sense).
\begin{Schunk}
\begin{Sinput}
> X <- c("A", "B", "C")
> ## ordinary set (X is converted to a set internally).
> gset(support = X)
\end{Sinput}
\begin{Soutput}
{A, B, C}
\end{Soutput}
\begin{Sinput}
> ## multiset
> multi <- 1:3
> gset(support = X, memberships = multi)
\end{Sinput}
\begin{Soutput}
{A [1], B [2], C [3]}
\end{Soutput}
\begin{Sinput}
> ## fuzzy set
> ms <- c(0.1, 0.3, 1)
> gset(support = X, memberships = ms)
\end{Sinput}
\begin{Soutput}
{A [0.1], B [0.3], C [1]}
\end{Soutput}
\begin{Sinput}
> ## fuzzy set using a membership function
> f <- function(x) switch(x, A = 0.1, B = 0.2, C = 1, 0)
> gset(support = X, charfun = f)
\end{Sinput}
\begin{Soutput}
{A [0.1], B [0.2], C [1]}
\end{Soutput}
\begin{Sinput}
> ## fuzzy multiset
> ## Here, the membership argument expects a list of membership grades,
> ## either specified as vectors, or as multisets.
> ms2 <- list(c(0.1, 0.3, 0.4), c(1, 1),
+             gset(support = ms, memberships = multi))
> gset(support = X, memberships = ms2)
\end{Sinput}
\begin{Soutput}
{A [{0.1, 0.3, 0.4}], B [{1 [2]}], C [{0.1 [1], 0.3 [2], 1 [3]}]}
\end{Soutput}
\end{Schunk}
As for ordinary sets, the usual operations
such as union, intersection, and complement are available.
Additionally, the sum and the difference of sets are defined,
which add and subtract multiplicities:
\begin{Schunk}
\begin{Sinput}
> X <- gset(c("A", "B", "C"), 4:6)
> print(X)
\end{Sinput}
\begin{Soutput}
{A [4], B [5], C [6]}
\end{Soutput}
\begin{Sinput}
> Y <- gset(c("B", "C", "D"), 1:3)
> print(Y)
\end{Sinput}
\begin{Soutput}
{B [1], C [2], D [3]}
\end{Soutput}
\begin{Sinput}
> ## union vs. sum
> gset_union(X, Y)
\end{Sinput}
\begin{Soutput}
{A [4], B [5], C [6], D [3]}
\end{Soutput}
\begin{Sinput}
> gset_sum(X, Y)
\end{Sinput}
\begin{Soutput}
{A [4], B [6], C [8], D [3]}
\end{Soutput}
\begin{Sinput}
> ## intersection vs. difference
> gset_intersection(X, Y)
\end{Sinput}
\begin{Soutput}
{B [1], C [2]}
\end{Soutput}
\begin{Sinput}
> gset_difference(X, Y)
\end{Sinput}
\begin{Soutput}
{A [4], B [4], C [4]}
\end{Soutput}
\begin{Sinput}
> ## sum and difference for fuzzy sets
> X <- gset("a", 0.3)
> Y <- gset(c("a", "b"), c(0.3, 0.4))
> gset_sum(X, Y)
\end{Sinput}
\begin{Soutput}
{a [{0.3 [2]}], b [{0.4}]}
\end{Soutput}
\begin{Sinput}
> gset_sum(X, Y, set("a"))
\end{Sinput}
\begin{Soutput}
{a [{0.3 [2], 1 [1]}], b [{0.4}]}
\end{Soutput}
\begin{Sinput}
> gset_difference(Y, X)
\end{Sinput}
\begin{Soutput}
{b [{0.4}]}
\end{Soutput}
\end{Schunk}
Note that \code{"+"} and \code{"-"} can be used instead, and that for
fuzzy (multi-)sets, in
general, complement and difference do not yield the same result (as
for crisp sets):
\begin{Schunk}
\begin{Sinput}
> X - Y
\end{Sinput}
\begin{Soutput}
{}
\end{Soutput}
\begin{Sinput}
> gset_complement(X, Y)
\end{Sinput}
\begin{Soutput}
{a [0.3], b [0.4]}
\end{Soutput}
\end{Schunk}

For fuzzy (multi-)sets, the user can choose the logic underlying the
operations using the \codefun{fuzzy\_logic} function.  Fuzzy logics are
represented as named lists with four components \code{N}, \code{T},
\code{S}, and \code{I} containing the corresponding functions for
negation, conjunction (``$t$-norm''), disjunction (``$t$-conorm''), and
implication.  The fuzzy logic is selected by calling
\codefun{fuzzy\_logic} with a character string specifying the fuzzy
logic ``family'', and optional parameters.  Available families include:
\code{"Zadeh"} (default), \code{"drastic"}, \code{"product"},
\code{"Lukasiewicz"}, \code{"Fodor"}, \code{"Frank"}, \code{"Hamacher"},
\code{"Schweizer-Sklar"}, \code{"Yager"}, \code{"Dombi"},
\code{"Aczel-Alsina"}, and \code{"Sugeno-Weber"}.  A call to
\codefun{fuzzy\_logic} without arguments returns the currently set fuzzy
logic.

\begin{Schunk}
\begin{Sinput}
> X <- gset(c("A", "B", "C"), c(0.3, 0.5, 0.8))
> print(X)
\end{Sinput}
\begin{Soutput}
{A [0.3], B [0.5], C [0.8]}
\end{Soutput}
\begin{Sinput}
> Y <- gset(c("B", "C", "D"), c(0.1, 0.3, 0.9))
> print(Y)
\end{Sinput}
\begin{Soutput}
{B [0.1], C [0.3], D [0.9]}
\end{Soutput}
\begin{Sinput}
> ## Zadeh-logic (default)
> gset_intersection(X, Y)
\end{Sinput}
\begin{Soutput}
{B [0.1], C [0.3]}
\end{Soutput}
\begin{Sinput}
> gset_union(X, Y)
\end{Sinput}
\begin{Soutput}
{A [0.3], B [0.5], C [0.8], D [0.9]}
\end{Soutput}
\begin{Sinput}
> gset_complement(X, Y)
\end{Sinput}
\begin{Soutput}
{B [0.1], C [0.2], D [0.9]}
\end{Soutput}
\begin{Sinput}
> !X
\end{Sinput}
\begin{Soutput}
{A [0.7], B [0.5], C [0.2]}
\end{Soutput}
\begin{Sinput}
> ## switch logic
> fuzzy_logic("Fodor")
> ## Fodor-logic
> gset_intersection(X, Y)
\end{Sinput}
\begin{Soutput}
{C [0.3]}
\end{Soutput}
\begin{Sinput}
> gset_union(X, Y)
\end{Sinput}
\begin{Soutput}
{A [0.3], B [0.5], C [1], D [0.9]}
\end{Soutput}
\begin{Sinput}
> gset_complement(X, Y)
\end{Sinput}
\begin{Soutput}
{D [0.9]}
\end{Soutput}
\begin{Sinput}
> !X
\end{Sinput}
\begin{Soutput}
{A [0.7], B [0.5], C [0.2]}
\end{Soutput}
\end{Schunk}
The \codefun{cut} method for generalized sets
\dQuote{filters} all elements with membership
not less then a specified level---the result, thus, is a crisp (multi)set:
\begin{Schunk}
\begin{Sinput}
> cut(X, 0.5)
\end{Sinput}
\begin{Soutput}
{B, C}
\end{Soutput}
\begin{Sinput}
> cut(X)
\end{Sinput}
\begin{Soutput}
{}
\end{Soutput}
\end{Schunk}
Additionally, there is a \codefun{plot} method for fuzzy (multi-)sets
that produces a barplot for the membership vector (see Figure \ref{fig:plot}):
\begin{Schunk}
\begin{Sinput}
> plot(X)
\end{Sinput}
\end{Schunk}

\begin{figure}[h]
\begin{center}
\includegraphics{set-017}
\caption{Membership plot for a fuzzy set.}
\label{fig:plot}
\end{center}
\end{figure}


% {\small
%   \bibliographystyle{abbrvnat}
%   \bibliography{sets}
% }

%\printindex{}

\end{document}
