\documentclass[a4paper]{article}
\usepackage[round,longnamesfirst]{natbib}
\usepackage{graphicx,keyval,thumbpdf,a4wide,makeidx,color,colordvi}
\usepackage{amsfonts,hyperref}

\newcommand\R{\textsf{R}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\sQuote}[1]{`{#1}'}
\newcommand{\dQuote}[1]{``{#1}''}
\newcommand{\file}[1]{\sQuote{\textsf{#1}}}
\newcommand{\data}[1]{\texttt{#1}}
\newcommand{\var}[1]{\textit{#1}}
\newcommand{\class}[1]{\textsf{#1}}
\newcommand{\proglang}[1]{\textsf{#1}}
%% \code without `-' ligatures
\def\nohyphenation{\hyphenchar\font=-1 \aftergroup\restorehyphenation}
\def\restorehyphenation{\hyphenchar\font=`-}
{\catcode`\-=\active%
  \global\def\code{\bgroup%
    \catcode`\-=\active \let-\codedash%
    \Rd@code}}
\def\codedash{-\discretionary{}{}{}}
\def\Rd@code#1{\texttt{\nohyphenation#1}\egroup}
\newcommand{\codefun}[1]{\code{#1()}}
\newcommand{\codefunind}[1]{\codefun{#1}\index{\texttt{#1}}}
\newcommand{\codeind}[1]{\code{#1}\index{\texttt{#1}}}

\SweaveOpts{strip.white=TRUE}

\AtBeginDocument{\setkeys{Gin}{width=0.5\textwidth}}

\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{Red}{rgb}{0.7,0,0}

\date{2008-11-26}
\title{Generalized and Customizable Sets in \R}
\author{David Meyer and Kurt Hornik}
%\VignetteIndexEntry{Sets}
%\VignetteDepends{sets}
%\VignetteKeywords{set, tuple, multiset, fuzzy set}
%\VignettePackage{sets}

\makeindex{}

\sloppy{}

\begin{document}
\maketitle

\begin{abstract}
This document explains algorithms and basic operations of
sets and some generalizations of sets (fuzzy
sets, multisets, and fuzzy multisets) available in \R{} through the
\pkg{sets} package.
\end{abstract}

<<echo=FALSE>>=
options(width = 80)
library("sets")
@ %

%\section{Introduction}
%\label{sec:introduction}

There is only rudimentary support in base \R{}~for \emph{sets}.
Typically, these are represented using atomic or recursive vectors
(lists), and one can use operations such as \codefun{union},
\codefun{intersect}, \codefun{setdiff}, \codefun{setequal}, and
\codefun{is.element} to emulate set operations.  However, there are
several drawbacks:  first of all, quite a few other operations such as
the Cartesian product, the power set, the subset predicate, etc., are
missing.  Then, the current facilities do not make use of a class
system, making extensions hard (if not impossible).  Another consequence
is that no distinction can be made between sequences (ordered
collections of objects) and sets (unordered collections of objects),
which is key for the definition of relations, where both concepts are
combined.  Also, there is no support for extensions such as fuzzy sets
or multisets. Therefore, we decided to provide more formalized and extended
support for sets, and, because they are needed for Cartesian products,
also for tuples.

\section{Tuples}
\label{sec:tuples}

The \emph{tuple} functions in package \pkg{sets} represent basic
infrastructure for handling tuples of general (\R) objects.  They are
used, e.g., to correctly represent Cartesian products of sets, resulting
in a set of tuples (see below).  Although tuple objects should behave
like \dQuote{ordinary} vectors for the most common operations (see
examples), some functions may yield unexpected results (e.g.,
\codefun{table}) or simply not work (e.g., \codefun{plot}) since tuple
objects are in fact list objects internally.  There are several
constructors:  \codefunind{tuple}
for arbitrarily many objects, and \codefunind{singleton},
\codefunind{pair}, and \codefunind{triple}
for tuples of lengths 1, 2 and 3, respectively.  Note that tuple elements
can be named.
<<tuples,keep.source=TRUE>>=
## Do not quote strings
sets_options("quote", FALSE)

## constructor
tuple(1,2,3, TRUE)
triple(1,2,3)
pair(Name = "David", Height = 185)
tuple_is_triple(triple(1,2,3))
tuple_is_ntuple(tuple(1,2,3,4), 4)

## converter
as.tuple(1:3)

## operations
c(tuple("a","b"), 1)
tuple(1,2,3) * tuple(2,3,4)
rep(tuple(1,2,3), 2)
@
The \codefun{Summary} methods will also work if defined for the
elements:
<<tuplesummary>>=
sum(tuple(1,2,3))
range(tuple(1,2,3))
@
In addition, there is a \codefunind{tuple\_outer}
function to apply functions to all combinations of tuple elements.  Note
that \codefun{tuple\_outer} will also work for regular vectors and thus
can really be seen as an extension of \codefun{outer}:
<<tupleouter>>=
tuple_outer(pair(1,2), triple(1,2,3))
tuple_outer(1:5, 1:4, "^")
@

\section{Sets}
\label{sec:sets}

The basic constructor for creating sets is the \codefunind{set}
function accepting an arbitrary number of \R{}~objects as arguments
(which can be named).  In addition, there is a generic \codefunind{as.set}
for converting suitable objects to sets.
<<sets1,keep.source=TRUE>>=
## constructor
s <- set(1, 2, 3)
s

## named elements
snamed <- set(one = 1, 2, three = 3)
snamed

## Indexing by label
snamed[["one"]]

## subassignment using element-based indexing
snamed[c(2,3)] <- c("a", "b")
snamed

## a more complex set
set(c, "test", list(1, 2, 3))

## set of sets
set(set(), set(1))

## conversion functions
s2 <- as.set(2:5)
s2
@
There are some basic predicate functions (and corresponding operators)
defined for the (in)equality, (proper) sub-(super-)set, and element-of.
Note that all the \codefun{set\_is\_\var{foo}} functions are vectorized:
<<setpredicates>>=
set_is_empty(set())
set_is_equal(set(1), set(1))
set(1) == set(1)
set(1) != set(2)

set_is_subset(set(1), set(1,2))
set(1) <= set(1,2)
set(1,2) >= set(1)

set_is_proper_subset(set(1), set(1))
set(1) < set(1)
set(1,2) > set(1)

set_contains_element(set(1,2,3), 1)
1 %e% set(1,2,3)

set_contains_element(set(1,2,3), 1:4)
1:4 %e% set(1,2,3)
@
Other than these predicate functions and operators, one can use:
\codefun{c} and \code{|} for the union, \code{-} for the
difference (or complement), \code{\&} for the intersection, \code{\%D\%} for the
symmetric difference, \code{*} and \code{\^{ }$n$} for the ($n$-fold)
Cartesian product (yielding a set of $n$-tuples), and \code{2\^} for the
power set.  \codefunind{set\_union}, \codefunind{set\_intersection}, and
\codefunind{set\_symdiff} accept more than two arguments.\footnote{The
  $n$-ary symmetric difference of a collection of sets consists of all
  elements contained in an odd number of the sets in the collection.}
The \code{length} method for sets gives the cardinality.
\codefunind{set\_combn} returns the set of all subsets of specified
length. \codefun{closure} and \codefun{reduction} compute the closure
and reduction under union, intersection, and symmetric difference.
Note that (currently) the \codefun{rep} method for sets will
just return its argument since set elements are unique.
<<setops,keep.source=TRUE>>=
length(s)
length(set())

## complement, union, intersection, symmetric difference:
s - 1
s + set("a")
s | set("a")
s & s2
s %D% s2
set(1,2,3) - set(1,2)

set_intersection(set(1,2,3), set(2,3,4), set(3,4,5))
set_union(set(1,2,3), set(2,3,4), set(3,4,5))
set_symdiff(set(1,2,3), set(2,3,4), set(3,4,5))

## Cartesian product
s * s2
s * s
s ^ 2 # same as above
s ^ 3

## power set
2 ^ s

## subsets:
set_combn(as.set(1:3),2)

## closure and reduction (under union):
cl <- closure(set(set(1), set(2), set(3)))
print(cl)
reduction(cl)
@
The \codefun{Summary} methods will also work if defined for the
elements:
<<setsummary>>=
sum(s)
range(s)
@
Using \codefunind{set\_outer},
it is possible to apply a function on all factorial combinations of the
elements of two sets.  If only one set is specified, the function is
applied to all pairs of this set.
<<setouter>>=
set_outer(set(1,2), set(1,2,3), "/")
X <- set_outer(set(1,2), set(1,2,3), set)
X[[2,3]]
set_outer(2 ^ set(1,2,3), set_is_subset)
@
Because set elements are unordered,
it is not allowed to use positional
subscripting.  However, as shown before, it is possible to use the
elements or their labels as index. Further,
it is possible to iterate over \emph{all}
elements using \codefun{for} and \codefun{lapply}/\codefun{sapply}:
<<iterators>>=
sapply(s, sqrt)
for (i in s) print(i)
@

\section{Generalized Sets}
\label{sec:gsets}

There are several extensions of \dQuote{ordinary} sets such as \emph{fuzzy sets}
and \emph{multisets}. Both can be be seen as special cases of
\emph{fuzzy multisets}. For all extensions, the approach is to define
a generalized set $X$ as a pair $(D, f)$ where $D$ is an ordinary set
representing the domain,
and $f$ the characteristic function of $X$, mapping
$D$ to some image $I$.  The subset of the domain for which $f$ is
non-zero is the support of $X$.
If $I=\{0, 1\}$, $X$
represents an \dQuote{ordinary} set. If $I=\mathbb{N}$, $X$ becomes
a multiset whose elements $e_i$ can appear multiple times. $f(e_i)$ is
then called the multiplicity of $e_i$. If $I$ is the unit interval,
$X$ becomes a fuzzy set. In this context, $f$ is typically called the membership
function, $f(e_i)$ the membership grade of $e_i$, and $D$ the universe
for $X$. If $I$ is a multiset whose domain is the unit interval (0 excluded),
$X$ is a fuzzy multiset whose elements can each have several
(possibly non-unique) membership grades. If for one element, the
asociated membership grades are all $1$, we get a multiset. If there
is at most one membership grade, we get a \dQuote{simple} fuzzy set. If for
the latter case the membership is $1$, we fall back to an ordinary set.

Generalized sets are created using the \codefun{gset} function. This
can be done in four ways:

\begin{enumerate}
\item Specify the support only (this yields an ordinary set).
\item Specify support and memberships.
\item Specify universe and membership function.
\item Specify a set of elements along with their individual membership grades.
\end{enumerate}

\noindent Note that by default, for efficiency reasons, \codefun{gset} will not
store elements with zero memberships grades. The specification of an
universe is thus only mandatory with membership functions. A default
universe can be set using \codefun{sets\_options}.
<<keep.source=TRUE>>=
X <- c("A", "B", "C")

## ordinary set (X is converted to a set internally).
gset(support = X)

## multiset
multi <- 1:3
gset(support = X, memberships = multi)

## fuzzy set
ms <- c(0.1, 0.3, 1)
gset(support = X, memberships = ms)

## fuzzy set using a membership function
f <- function(x) switch(x, A = 0.1, B = 0.2, C = 1, 0)
gset(universe = X, charfun = f)

## fuzzy multiset
## Here, the membership argument expects a list of membership grades,
## either specified as vectors, or as multisets.
ms2 <- list(c(0.1, 0.3, 0.4), c(1, 1),
            gset(support = ms, memberships = multi))
gset(support = X, memberships = ms2)
@
\codefun{gset\_support}, \codefun{gset\_memberships}, \codefun{gset\_height}
and \codefun{gset\_core} can be used to retrieve support,
memberships, height (maximum membership degree),
and the core (elements with membership 1), respectively, of a
generalized set. \codefun{gset\_charfun} returns a (point-wise defined)
characteristic function for a given set.
Note that in general, this will be different
from the characteristic function possibly used for the creation of the set.

As for ordinary sets, the usual operations
such as union, intersection, and complement are available.
Additionally, the sum and the difference of sets are defined,
which add and subtract multiplicities:
<<keep.source=TRUE>>=
X <- gset(c("A", "B", "C"), 4:6)
print(X)
Y <- gset(c("B", "C", "D"), 1:3)
print(Y)

## union vs. sum
gset_union(X, Y)
gset_sum(X, Y)

## intersection vs. difference
gset_intersection(X, Y)
gset_difference(X, Y)

## sum and difference for fuzzy sets
X <- gset("a", 0.3)
Y <- gset(c("a", "b"), c(0.3, 0.4))
gset_sum(X, Y)
gset_sum(X, Y, set("a"))
gset_difference(Y, X)
@
Note that \code{+} and \code{-} can be used instead, and that for
fuzzy (multi-)sets, in
general, complement and difference do not yield the same result (as
for crisp sets):
<<>>=
X - Y
gset_complement(X, Y)
@
\codefun{gset\_mean} creates a new set by averaging corresponding
memberships using the arithmetic, geometric or harmonic mean.
Note that missing elements have 0 membership degree:
<<>>=
x <- gset(1:3, 1:3/3)
y <- gset(1:2, 1:2/2)
gset_mean(x, y)
gset_mean(x, y, "harmonic")

gset_mean(set(1), set(1, 2))
@

The membership vector of a generalized set can be transformed using
\codefun{gset\_transform\_memberships}, using any \emph{vectorized} function:
<<>>=
x <- gset(1:10, 1:10/10)
gset_transform_memberships(x, pmax, 0.5)
@
Note the effect of applying transformations to (multi)sets:
<<>>=
x = gset(1, 2)
gset_transform_memberships(x, `*`, 0.5)

## compare this to:
rep(x, 0.5)
@
In addition, three convenience functions exist: \codefun{gset\_concentrate} and
\codefun{gset\_dilate} apply the square and the square root function,
and \codefun{gset\_normalize} normalizes the memberships to a specified
maximum:
<<>>=
gset_dilate(y)
gset_concentrate(y)
gset_normalize(y, 0.5)
@

For fuzzy (multi-)sets, the user can choose the logic underlying the
operations using the \codefun{fuzzy\_logic} function.  Fuzzy logics are
represented as named lists with four components \code{N}, \code{T},
\code{S}, and \code{I} containing the corresponding functions for
negation, conjunction (``t-norm''), disjunction (``t-conorm''), and
implication.  The fuzzy logic is selected by calling
\codefun{fuzzy\_logic} with a character string specifying the fuzzy
logic ``family'', and optional parameters.  Available families include:
\code{"Zadeh"} (default), \code{"drastic"}, \code{"product"},
\code{"Lukasiewicz"}, \code{"Fodor"}, \code{"Frank"}, \code{"Hamacher"},
\code{"Schweizer-Sklar"}, \code{"Yager"}, \code{"Dombi"},
\code{"Aczel-Alsina"}, \code{"Sugeno-Weber"}, \code{"Dubois-Prade"},
and \code{"Yu"}. A call to
\codefun{fuzzy\_logic} without arguments returns the currently set fuzzy
logic.

<<keep.source=TRUE>>=
X <- gset(c("A", "B", "C"), c(0.3, 0.5, 0.8))
print(X)
Y <- gset(c("B", "C", "D"), c(0.1, 0.3, 0.9))
print(Y)

## Zadeh logic (default)
gset_intersection(X, Y)
gset_union(X, Y)
gset_complement(X, Y)
!X

## switch logic
fuzzy_logic("Fodor")

## Fodor logic
gset_intersection(X, Y)
gset_union(X, Y)
gset_complement(X, Y)
!X
@
The \codefun{cut} method for generalized sets
\dQuote{filters} all elements with membership
not less then a specified level---the result, thus, is a crisp (multi)set:
<<>>=
cut(X, 0.5)
## default level is 1, so this filters all "crisp" elements:
cut(X)
@

<<echo=FALSE>>=
fuzzy_logic("Zadeh")
@

\section{Characteristic Functions and their Visualization}
\label{sec:plots}

The \pkg{sets} package provides several generators of
characteristic functions to be used as templates for the creation of
fuzzy sets, including the following shapes:
gaussian curve (\codefun{fuzzy\_normal}),
double gaussian curve (\codefun{fuzzy\_two\_normals}),
bell curve (\codefun{fuzzy\_bell}),
sigmoid curve (\codefun{fuzzy\_sigmoid}),
trapezoid (\codefun{fuzzy\_trapezoid}),
and triangle (\codefun{fuzzy\_triangular}, \codefun{fuzzy\_cone}).
<<>>=
## creating a fuzzy normal function
N <- fuzzy_normal(mean = 0, sd = 1)
N(-3:3)

## create a fuzzy set with it
gset(charfun = N, universe = -3:3)
@
For convenience, we
also provide wrappers that directly generate corresponding sets,
given a specified (default) universe:
<<>>=
fuzzy_normal_gset(universe = -3:3)
@
It is also possible to create function generators for characteristic
functions from other functions (such as distribution functions):
<<>>=
## creating a user-defined fuzzy function
## (note: fuzzy_poisson will only be defined for positive integers)
fuzzy_poisson <- charfun_generator(dpois)
gset(charfun = fuzzy_poisson(10), universe = seq(0, 20, 2))
@
\codefun{make\_fuzzy\_tuple} generates a sequence (tuple) of
sets based on any of the generating functions (except
\codefun{fuzzy\_trapezoid} and \codefun{fuzzy\_triangular}). The chosen
generating function is called with different
values (chosen along the universe) passed to the
first argument, thus varying the position or the resulting graph:
<<>>=
## creating a series of fuzzy normal sets
fuzzy_tuple(fuzzy_normal, 5)
@

The \pkg{sets} package provides support for visualizing the
membership functions of generalized
sets, and in particular fuzzy sets.
For (fuzzy) multisets, the plot method
produces a (grouped) barplot for
the membership vector (see Figure \ref{fig:plots}, top left):
<<plot1,fig=FALSE>>=
## a fuzzy multiset
X <- gset(c("A", "B"), list(1:2/2, 0.5))
plot(X)
@
Characteristic function generators can directly be plotted using a
default universe (see Figure \ref{fig:plots}, top right):
<<plot2,fig=FALSE>>=
plot(fuzzy_bell)
@
There is a plot method for tuples for visualizing a sequence
of sets (see Figure \ref{fig:plots}, bottom left):
<<plot3,fig=FALSE>>=
## creating a sequence of sets
plot(fuzzy_tuple(fuzzy_cone, 10), col = gray.colors(10))
@
Plots of several sets can be superposed using the line method (see
Figure \ref{fig:plots}, bottom right):
<<plot4,fig=FALSE>>=
x <- fuzzy_normal_gset()
y <- fuzzy_trapezoid_gset(corners = c(5,10,15,17), height = c(0.7, 1))
plot(tuple(x, y), lty = 3)
lines(x | y, col = 2)
lines(gset_mean(x, y), col = 3, lty = 2)
@

\setkeys{Gin}{width=0.45\textwidth}
\begin{figure}[h]
\begin{center}
<<plot1fig,fig=TRUE,echo=FALSE>>=
<<plot1>>
@
\hfill
<<plot2fig,fig=TRUE,echo=FALSE>>=
<<plot2>>
@
\hfill
<<plot3fig,fig=TRUE,echo=FALSE>>=
<<plot3>>
@
\hfill
<<plot4fig,fig=TRUE,echo=FALSE>>=
<<plot4>>
@
\caption{Membership plots for fuzzy sets. Top left: grouped barplot
  for a fuzzy multiset. Top right: graph of a bell curve. Bottom left:
sequence of triangular functions. Bottom right: two combinations of a
normal and a trapzoid function (dotted lines: basic shapes;
solid (red) line: union; dashed (green) line: arithmetic mean).}
\label{fig:plots}
\end{center}
\end{figure}

\section{Customizable Sets}
\label{sec:csets}

Customizable sets extend generalized sets in two ways: First, users
can control the way elements are matched, i.e., define equivalence
classes of elements. Second, arbitrary iteration orders can be specified.

By default, sets and generalized sets use
\codefun{identical} to match elements which is maximal
restrictive. Customizable sets can be used to obtain the behavior of
\code{"=="} or \codefun{match}.

<<keep.source=TRUE>>=
## restore string quoting
sets_options("quote", TRUE)

## default behavior of sets: matching of elements is very strict
## Note that on most systems, 3.3 - 2.2 != 1.1
x <- set("1", 1L, 1, 3.3 - 2.2, 1.1)
print(x)

y <- set(1, 1.1, 2L, "2")
print(y)
1L %e% y

set_union(x, y)
set_intersection(x, y)
set_complement(x, y)

### Now use the more sloppy match()-function (i.e., `==`)
### Note that 1 == "1" == 1L ...
X <- cset(x, matchfun = match)
print(X)
Y <- cset(y, matchfun = match)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)

## Same using all.equal().
## This is a non-vectorized predicate, so use matchfun
## to generate a vectorized version:
FUN <- matchfun(function(x, y) isTRUE(all.equal(x, y)))
X <- cset(x, matchfun = FUN)
print(X)
Y <- cset(y, matchfun = FUN)
print(Y)
1L %e% Y

cset_union(X, Y)
cset_intersection(X, Y)
cset_complement(X, Y)
@

\noindent \codefunind{set\_options} can be used to conveniently switch the
default match and/or order function if a number of \class{cset} objects need
to be created.

<<keep.source=TRUE>>=
### change default functions via sets_option
sets_options("matchfun", match)
cset(x)
cset(y)

cset(1:3) <= cset(c(1,2,3))

### restore package defaults
sets_options("matchfun", NULL)
@

In addition, an order function (or permutation index)
can be specified for each set for changing the order in which
iterators such as \codefun{as.list} process the elements. The latter in
particular influences the labeling and print methods for
customizable sets. Sets and generalized sets have a canonical internal
ordering which by default is also used for iterations. With
customizable sets, a ``natural'' ordering of elements can be kept.

<<keep.source=TRUE>>=
## simple example using a permutation index vector
cset(letters[1:5], orderfun = 5:1)

### customized order function
FUN <- function(x) order(as.character(x), decreasing = TRUE)
Z <- cset(letters[1:5], orderfun = FUN)
print(Z)
as.character(Z)
@

\noindent Note that converters for ordered factors keeps the order:

<<keep.source=TRUE>>=
o <- ordered(c("a", "b", "a"), levels = c("b", "a"))
as.set(o)
as.cset(o)
@
\noindent Converter for other data types keep order if the elements are unique:

<<keep.source=TRUE>>=
as.cset(c("A", "quick", "brown", "fox"))
as.cset(c("A", "quick", "brown", "fox", "quick"))
@
% {\small
%   \bibliographystyle{abbrvnat}
%   \bibliography{sets}
% }

%\printindex{}

\end{document}
